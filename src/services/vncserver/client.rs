//! VNC client connection handler for generic async streams.
//!
//! This module manages a single VNC client connection, handling the RFB protocol
//! handshake, message processing, and framebuffer update delivery. Unlike the
//! reference implementation which uses `TcpStream`, this version works with any
//! stream implementing `AsyncRead + AsyncWrite + Unpin + Send` — enabling use
//! with rathole tunnel streams.
//!
//! # Architecture
//!
//! The client operates in two phases:
//! 1. **Handshake** — Protocol version, security negotiation, ServerInit
//! 2. **Message loop** — Reads client messages and sends framebuffer updates
//!
//! The stream is split via `tokio::io::split()` into independent read/write halves,
//! allowing concurrent message reading and update sending.

use std::sync::atomic::{AtomicBool, AtomicU8, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};

use bytes::{Buf, BufMut, BytesMut};
use flate2::Compress;
use tokio::io::{AsyncReadExt, AsyncWriteExt, ReadHalf, WriteHalf};
use tokio::sync::{mpsc, RwLock};
use tracing::{debug, error, info, warn};

use super::auth::VncAuth;
use super::encoding::{to_rfb_pixel_format, TightZlibStreams};
use super::framebuffer::{DirtyRegion, DirtyRegionReceiver, Framebuffer};
use super::protocol::{
    PixelFormat, Rectangle, ServerInit, CLIENT_MSG_CLIENT_CUT_TEXT,
    CLIENT_MSG_FRAMEBUFFER_UPDATE_REQUEST, CLIENT_MSG_KEY_EVENT, CLIENT_MSG_POINTER_EVENT,
    CLIENT_MSG_SET_ENCODINGS, CLIENT_MSG_SET_PIXEL_FORMAT, ENCODING_COMPRESS_LEVEL_0,
    ENCODING_COMPRESS_LEVEL_9, ENCODING_COPYRECT, ENCODING_QUALITY_LEVEL_0,
    ENCODING_QUALITY_LEVEL_9, ENCODING_RAW, ENCODING_TIGHT, ENCODING_ZLIB, ENCODING_ZRLE,
    PROTOCOL_VERSION, SECURITY_RESULT_FAILED, SECURITY_RESULT_OK, SECURITY_TYPE_NONE,
    SECURITY_TYPE_VNC_AUTH, SERVER_MSG_FRAMEBUFFER_UPDATE, UPDATE_BUF_SIZE,
};

/// Events generated by a VNC client and sent to the server.
#[derive(Debug)]
pub enum ClientEvent {
    /// A key press or release event.
    KeyPress {
        /// `true` if the key is pressed, `false` if released.
        down: bool,
        /// The X Window System keysym of the key.
        key: u32,
    },
    /// A pointer (mouse) movement or button event.
    PointerMove {
        /// X-coordinate of the pointer.
        x: u16,
        /// Y-coordinate of the pointer.
        y: u16,
        /// Bitmask indicating which mouse buttons are pressed.
        button_mask: u8,
    },
    /// Client clipboard (cut text) update.
    CutText {
        /// The textual content from the client's clipboard.
        text: String,
    },
    /// Client has disconnected.
    Disconnected,
}

/// Manages a single VNC client connection over a generic async stream.
///
/// Handles communication, framebuffer updates, and client input events.
/// Uses `tokio::io::split()` to work with any `AsyncRead + AsyncWrite` stream.
pub struct VncClient<S: AsyncReadExt + AsyncWriteExt + Unpin + Send> {
    /// The read half of the split stream.
    read_stream: ReadHalf<S>,
    /// The write half of the split stream (behind mutex for concurrent access).
    write_stream: Arc<tokio::sync::Mutex<WriteHalf<S>>>,
    /// Reference to the shared framebuffer.
    framebuffer: Framebuffer,
    /// Client's requested pixel format.
    pixel_format: RwLock<PixelFormat>,
    /// Client's preferred encodings list.
    encodings: RwLock<Vec<i32>>,
    /// Sender for client events.
    event_tx: mpsc::UnboundedSender<ClientEvent>,
    /// Last time a framebuffer update was sent.
    last_update_sent: RwLock<Instant>,
    /// JPEG quality (1-100) for Tight encoding.
    jpeg_quality: AtomicU8,
    /// Zlib compression level (0-9).
    compression_level: AtomicU8,
    /// VNC quality level (0-9, 255 = unset).
    quality_level: AtomicU8,
    /// Whether the client has requested an update.
    update_requested: AtomicBool,
    /// Per-client dirty regions (pushed from framebuffer).
    modified_regions: Arc<RwLock<Vec<DirtyRegion>>>,
    /// Region requested by the client for update.
    requested_region: RwLock<Option<DirtyRegion>>,
    /// Update deferral duration.
    defer_update_time: Duration,
    /// Persistent zlib compressor for Zlib encoding.
    zlib_compressor: RwLock<Option<Compress>>,
    /// Persistent zlib compressor for ZRLE encoding.
    zrle_compressor: RwLock<Option<Compress>>,
    /// Persistent zlib streams for Tight encoding (4 streams).
    tight_zlib_streams: RwLock<TightZlibStreams>,
}

/// VNC quality level to JPEG quality mapping (TigerVNC compatible).
const TIGHT2TURBO_QUAL: [u8; 10] = [15, 29, 41, 42, 62, 77, 79, 86, 92, 100];

/// Maximum clipboard size to prevent memory exhaustion attacks.
const MAX_CUT_TEXT: usize = 10 * 1024 * 1024; // 10MB

impl<S: AsyncReadExt + AsyncWriteExt + Unpin + Send> VncClient<S> {
    /// Performs the VNC handshake and creates a new [`VncClient`].
    ///
    /// This handles:
    /// 1. Protocol version exchange (RFB 003.008)
    /// 2. Security type negotiation (None or VNC Auth)
    /// 3. Authentication (if password set)
    /// 4. ClientInit/ServerInit exchange
    ///
    /// After handshake, the stream is split for concurrent read/write.
    ///
    /// # Arguments
    ///
    /// * `stream` - Any async stream implementing `AsyncRead + AsyncWrite + Unpin + Send`
    /// * `framebuffer` - Shared framebuffer instance
    /// * `desktop_name` - Name sent to the client in ServerInit
    /// * `password` - Optional VNC password (None = no authentication)
    /// * `event_tx` - Channel sender for client events
    ///
    /// # Errors
    ///
    /// Returns `std::io::Error` on I/O errors or authentication failure.
    #[allow(clippy::too_many_lines)]
    pub async fn new(
        mut stream: S,
        framebuffer: Framebuffer,
        desktop_name: String,
        password: Option<String>,
        event_tx: mpsc::UnboundedSender<ClientEvent>,
    ) -> Result<Self, std::io::Error> {
        // --- Protocol Version ---
        stream.write_all(PROTOCOL_VERSION.as_bytes()).await?;

        let mut version_buf = vec![0u8; 12];
        stream.read_exact(&mut version_buf).await?;
        debug!(
            "VNC client version: {}",
            String::from_utf8_lossy(&version_buf).trim()
        );

        // --- Security Types ---
        if password.is_some() {
            // Offer VNC Authentication
            stream.write_all(&[1, SECURITY_TYPE_VNC_AUTH]).await?;
        } else {
            // Offer no authentication
            stream.write_all(&[1, SECURITY_TYPE_NONE]).await?;
        }

        // Read client's security type choice
        let mut sec_type = [0u8; 1];
        stream.read_exact(&mut sec_type).await?;

        // --- Authentication ---
        if sec_type[0] == SECURITY_TYPE_VNC_AUTH {
            let auth = VncAuth::new(password);
            let challenge = auth.generate_challenge();
            stream.write_all(&challenge).await?;

            let mut response = vec![0u8; 16];
            stream.read_exact(&mut response).await?;

            if auth.verify_response(&response, &challenge) {
                let mut buf = BytesMut::with_capacity(4);
                buf.put_u32(SECURITY_RESULT_OK);
                stream.write_all(&buf).await?;
                info!("VNC authentication successful");
            } else {
                let mut buf = BytesMut::with_capacity(4);
                buf.put_u32(SECURITY_RESULT_FAILED);
                stream.write_all(&buf).await?;
                return Err(std::io::Error::new(
                    std::io::ErrorKind::PermissionDenied,
                    "VNC authentication failed",
                ));
            }
        } else if sec_type[0] == SECURITY_TYPE_NONE {
            let mut buf = BytesMut::with_capacity(4);
            buf.put_u32(SECURITY_RESULT_OK);
            stream.write_all(&buf).await?;
        } else {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Unknown security type: {}", sec_type[0]),
            ));
        }

        // --- ClientInit ---
        let mut shared = [0u8; 1];
        stream.read_exact(&mut shared).await?;
        debug!("VNC ClientInit shared={}", shared[0]);

        // --- ServerInit ---
        let server_init = ServerInit {
            framebuffer_width: framebuffer.width(),
            framebuffer_height: framebuffer.height(),
            pixel_format: PixelFormat::rgba32(),
            name: desktop_name,
        };

        let mut init_buf = BytesMut::new();
        server_init.write_to(&mut init_buf);
        stream.write_all(&init_buf).await?;

        info!(
            "VNC handshake completed ({}x{})",
            framebuffer.width(),
            framebuffer.height()
        );

        // Split stream for concurrent read/write using tokio::io::split()
        let (read_stream, write_stream) = tokio::io::split(stream);

        let creation_time = Instant::now();

        Ok(Self {
            read_stream,
            write_stream: Arc::new(tokio::sync::Mutex::new(write_stream)),
            framebuffer,
            pixel_format: RwLock::new(PixelFormat::rgba32()),
            encodings: RwLock::new(vec![ENCODING_RAW]),
            event_tx,
            last_update_sent: RwLock::new(creation_time),
            jpeg_quality: AtomicU8::new(80),
            compression_level: AtomicU8::new(6),
            quality_level: AtomicU8::new(255), // unset
            update_requested: AtomicBool::new(false),
            modified_regions: Arc::new(RwLock::new(Vec::new())),
            requested_region: RwLock::new(None),
            defer_update_time: Duration::from_millis(5),
            zlib_compressor: RwLock::new(None),
            zrle_compressor: RwLock::new(None),
            tight_zlib_streams: RwLock::new(TightZlibStreams::new()),
        })
    }

    /// Returns a [`DirtyRegionReceiver`] for registering this client with the framebuffer.
    ///
    /// The framebuffer will push dirty regions to this receiver when pixels change.
    pub fn dirty_region_receiver(&self) -> DirtyRegionReceiver {
        DirtyRegionReceiver::new(Arc::downgrade(&self.modified_regions))
    }

    /// Enters the main message loop, processing client messages and sending updates.
    ///
    /// This runs until the client disconnects or an error occurs. It uses `tokio::select!`
    /// to concurrently:
    /// - Read and process client messages (SetPixelFormat, SetEncodings, key/pointer events)
    /// - Send framebuffer updates at regular intervals when regions are dirty
    ///
    /// # Errors
    ///
    /// Returns `std::io::Error` on I/O errors or protocol violations.
    #[allow(clippy::too_many_lines)]
    #[allow(clippy::cast_possible_truncation)]
    pub async fn handle_messages(&mut self) -> Result<(), std::io::Error> {
        let mut buf = BytesMut::with_capacity(4096);
        let mut check_interval = tokio::time::interval(tokio::time::Duration::from_millis(16)); // ~60fps check rate

        loop {
            tokio::select! {
                // Handle incoming client messages
                result = self.read_stream.read_buf(&mut buf) => {
                    let n = result?;
                    if n == 0 {
                        let _ = self.event_tx.send(ClientEvent::Disconnected);
                        return Ok(());
                    }

                    // Process all complete messages in the buffer
                    while !buf.is_empty() {
                        if !self.process_message(&mut buf).await? {
                            break; // Need more data
                        }
                    }
                }

                // Periodically check for and send framebuffer updates
                _ = check_interval.tick() => {
                    if self.should_send_update().await {
                        if let Err(e) = self.send_framebuffer_update().await {
                            error!("Failed to send framebuffer update: {}", e);
                            return Err(e);
                        }
                    }
                }
            }
        }
    }

    /// Process a single VNC client message from the buffer.
    ///
    /// Returns `Ok(true)` if a message was fully consumed, `Ok(false)` if more data needed.
    #[allow(clippy::cast_possible_truncation)]
    async fn process_message(&mut self, buf: &mut BytesMut) -> Result<bool, std::io::Error> {
        if buf.is_empty() {
            return Ok(false);
        }

        let msg_type = buf[0];

        match msg_type {
            CLIENT_MSG_SET_PIXEL_FORMAT => {
                if buf.len() < 20 {
                    return Ok(false); // 1 type + 3 padding + 16 pixel format
                }
                buf.advance(4); // type + padding

                let pf = PixelFormat::from_bytes(&buf[..16])?;
                buf.advance(16);

                if !pf.is_valid() {
                    warn!("Client requested invalid pixel format: {:?}", pf);
                    return Err(std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        "Invalid pixel format",
                    ));
                }

                debug!(
                    "Client set pixel format: {}bpp, depth={}, compatible_rgba32={}",
                    pf.bits_per_pixel,
                    pf.depth,
                    pf.is_compatible_with_rgba32()
                );
                *self.pixel_format.write().await = pf;
            }

            CLIENT_MSG_SET_ENCODINGS => {
                if buf.len() < 4 {
                    return Ok(false); // 1 type + 1 padding + 2 count
                }
                let count = u16::from_be_bytes([buf[2], buf[3]]) as usize;
                let total_len = 4 + count * 4;
                if buf.len() < total_len {
                    return Ok(false);
                }

                buf.advance(4); // type + padding + count
                let mut encodings_list = Vec::with_capacity(count);
                for _ in 0..count {
                    let encoding = buf.get_i32();
                    encodings_list.push(encoding);

                    // Check for quality level pseudo-encodings (-32 to -23)
                    if (ENCODING_QUALITY_LEVEL_0..=ENCODING_QUALITY_LEVEL_9).contains(&encoding) {
                        let quality_level = (encoding - ENCODING_QUALITY_LEVEL_0) as u8;
                        let quality = TIGHT2TURBO_QUAL[quality_level as usize];
                        self.jpeg_quality.store(quality, Ordering::Relaxed);
                        self.quality_level.store(quality_level, Ordering::Relaxed);
                        debug!("Quality level {}, JPEG quality {}", quality_level, quality);
                    }

                    // Check for compression level pseudo-encodings (-256 to -247)
                    if (ENCODING_COMPRESS_LEVEL_0..=ENCODING_COMPRESS_LEVEL_9).contains(&encoding) {
                        let level = (encoding - ENCODING_COMPRESS_LEVEL_0) as u8;
                        self.compression_level.store(level, Ordering::Relaxed);
                        debug!("Compression level {}", level);
                    }
                }

                debug!("Client set {} encodings: {:?}", count, encodings_list);
                *self.encodings.write().await = encodings_list;
            }

            CLIENT_MSG_FRAMEBUFFER_UPDATE_REQUEST => {
                if buf.len() < 10 {
                    return Ok(false); // 1 type + 1 incremental + 8 (x,y,w,h)
                }
                buf.advance(1);
                let incremental = buf.get_u8() != 0;
                let x = buf.get_u16();
                let y = buf.get_u16();
                let width = buf.get_u16();
                let height = buf.get_u16();

                *self.requested_region.write().await = Some(DirtyRegion::new(x, y, width, height));
                self.update_requested.store(true, Ordering::Relaxed);

                // Non-incremental = full refresh
                if !incremental {
                    let full_region = DirtyRegion::new(x, y, width, height);
                    let mut regions = self.modified_regions.write().await;
                    regions.clear();
                    regions.push(full_region);
                }
            }

            CLIENT_MSG_KEY_EVENT => {
                if buf.len() < 8 {
                    return Ok(false); // 1 type + 1 down + 2 padding + 4 key
                }
                buf.advance(1);
                let down = buf.get_u8() != 0;
                buf.advance(2); // padding
                let key = buf.get_u32();

                let _ = self.event_tx.send(ClientEvent::KeyPress { down, key });
            }

            CLIENT_MSG_POINTER_EVENT => {
                if buf.len() < 6 {
                    return Ok(false); // 1 type + 1 button_mask + 2 x + 2 y
                }
                buf.advance(1);
                let button_mask = buf.get_u8();
                let x = buf.get_u16();
                let y = buf.get_u16();

                let _ = self
                    .event_tx
                    .send(ClientEvent::PointerMove { x, y, button_mask });
            }

            CLIENT_MSG_CLIENT_CUT_TEXT => {
                if buf.len() < 8 {
                    return Ok(false); // 1 type + 3 padding + 4 length
                }
                let length = u32::from_be_bytes([buf[4], buf[5], buf[6], buf[7]]) as usize;
                let total_len = 8 + length;
                if buf.len() < total_len {
                    return Ok(false);
                }

                buf.advance(8); // type + padding + length

                if length > MAX_CUT_TEXT {
                    warn!("Cut text too large ({} bytes), skipping", length);
                    buf.advance(length);
                } else {
                    let text_bytes = buf.split_to(length);
                    if let Ok(text) = String::from_utf8(text_bytes.to_vec()) {
                        let _ = self.event_tx.send(ClientEvent::CutText { text });
                    }
                }
            }

            _ => {
                warn!("Unknown VNC message type: {}", msg_type);
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Unknown message type: {msg_type}"),
                ));
            }
        }

        Ok(true)
    }

    /// Check whether a framebuffer update should be sent.
    async fn should_send_update(&self) -> bool {
        if !self.update_requested.load(Ordering::Relaxed) {
            return false;
        }

        // Check if there are dirty regions
        let regions = self.modified_regions.read().await;
        if regions.is_empty() {
            return false;
        }

        // Check deferral timer
        let last_sent = self.last_update_sent.read().await;
        last_sent.elapsed() >= self.defer_update_time
    }

    /// Send a framebuffer update to the client.
    ///
    /// Takes all pending dirty regions, encodes them using the client's preferred
    /// encoding, and sends the update message.
    #[allow(clippy::too_many_lines)]
    #[allow(clippy::cast_possible_truncation)]
    async fn send_framebuffer_update(&self) -> Result<(), std::io::Error> {
        // Take ownership of pending regions
        let mut regions = self.modified_regions.write().await;
        if regions.is_empty() {
            return Ok(());
        }
        let modified_regions: Vec<DirtyRegion> = regions.drain(..).collect();
        drop(regions);

        // Determine preferred encoding
        let encodings = self.encodings.read().await;
        let preferred_encoding = encodings
            .iter()
            .find(|&&enc| {
                if enc == ENCODING_COPYRECT {
                    return false;
                }
                matches!(enc, ENCODING_ZLIB | ENCODING_ZRLE | ENCODING_TIGHT)
                    || super::encoding::get_encoder(enc).is_some()
            })
            .copied()
            .unwrap_or(ENCODING_RAW);
        drop(encodings);

        let jpeg_quality = self.jpeg_quality.load(Ordering::Relaxed);
        let compression_level = self.compression_level.load(Ordering::Relaxed);
        let quality_level = self.quality_level.load(Ordering::Relaxed);

        // Pre-encode TIGHT regions to count sub-rectangles
        let mut tight_encoded_regions = Vec::new();
        let mut total_rects = 0usize;

        if preferred_encoding == ENCODING_TIGHT {
            let client_pf = self.pixel_format.read().await;
            let rfb_client_format = to_rfb_pixel_format(&client_pf);
            drop(client_pf);

            let mut tight_streams = self.tight_zlib_streams.write().await;

            for region in &modified_regions {
                let pixel_data = match self
                    .framebuffer
                    .get_rect(region.x, region.y, region.width, region.height)
                    .await
                {
                    Ok(data) => data,
                    Err(e) => {
                        error!(
                            "Failed to get rect ({},{} {}x{}): {}",
                            region.x, region.y, region.width, region.height, e
                        );
                        continue;
                    }
                };

                let sub_rects = rfb_encodings::tight::encode_tight_rects(
                    &pixel_data,
                    region.width,
                    region.height,
                    quality_level,
                    compression_level,
                    &rfb_client_format,
                    &mut *tight_streams,
                );

                total_rects += sub_rects.len();
                tight_encoded_regions.push((region, sub_rects));
            }
            drop(tight_streams);
        } else {
            total_rects = modified_regions.len();
        }

        if total_rects == 0 {
            return Ok(());
        }

        // Build response
        let mut response = BytesMut::new();
        response.put_u8(SERVER_MSG_FRAMEBUFFER_UPDATE);
        response.put_u8(0); // padding
        response.put_u16(total_rects as u16);

        // Handle TIGHT encoded regions
        if preferred_encoding == ENCODING_TIGHT {
            for (region, sub_rects) in &tight_encoded_regions {
                for (rel_x, rel_y, w, h, encoded) in sub_rects {
                    let rect_size = 12 + encoded.len();

                    if response.len() + rect_size > UPDATE_BUF_SIZE {
                        // Flush current buffer
                        let mut ws = self.write_stream.lock().await;
                        ws.write_all(&response).await?;
                        response.clear();
                    }

                    let rect = Rectangle {
                        x: region.x + rel_x,
                        y: region.y + rel_y,
                        width: *w,
                        height: *h,
                        encoding: ENCODING_TIGHT,
                    };
                    rect.write_header(&mut response);
                    response.extend_from_slice(encoded);
                }
            }
        } else {
            // Handle other encodings
            let client_pf = self.pixel_format.read().await;
            let rfb_client_format = to_rfb_pixel_format(&client_pf);
            let rfb_server_format = rfb_encodings::PixelFormat::rgba32();
            drop(client_pf);

            for region in &modified_regions {
                let pixel_data = match self
                    .framebuffer
                    .get_rect(region.x, region.y, region.width, region.height)
                    .await
                {
                    Ok(data) => data,
                    Err(e) => {
                        error!("Failed to get rect: {}", e);
                        continue;
                    }
                };

                let (actual_encoding, encoded) = if preferred_encoding == ENCODING_RAW {
                    let translated = if rfb_client_format.is_compatible_with_rgba32() {
                        // Fast path: strip alpha channel
                        let mut buf = BytesMut::with_capacity(
                            region.width as usize * region.height as usize * 4,
                        );
                        for chunk in pixel_data.chunks_exact(4) {
                            buf.put_u8(chunk[0]); // R
                            buf.put_u8(chunk[1]); // G
                            buf.put_u8(chunk[2]); // B
                            buf.put_u8(0); // Padding
                        }
                        buf
                    } else {
                        super::encoding::translate_pixels(
                            &pixel_data,
                            &rfb_server_format,
                            &rfb_client_format,
                        )
                    };
                    (ENCODING_RAW, translated)
                } else if preferred_encoding == ENCODING_ZLIB {
                    let translated = self.translate_pixels_for_client(
                        &pixel_data,
                        &rfb_server_format,
                        &rfb_client_format,
                        region,
                    );

                    let mut zlib_lock = self.zlib_compressor.write().await;
                    if zlib_lock.is_none() {
                        *zlib_lock = Some(Compress::new(
                            flate2::Compression::new(u32::from(compression_level)),
                            true,
                        ));
                    }
                    let zlib_comp = zlib_lock.as_mut().unwrap();

                    match super::encoding::encode_zlib_persistent(&translated, zlib_comp) {
                        Ok(data) => (ENCODING_ZLIB, BytesMut::from(&data[..])),
                        Err(e) => {
                            error!("ZLIB failed: {}, falling back to RAW", e);
                            (ENCODING_RAW, translated)
                        }
                    }
                } else if preferred_encoding == ENCODING_ZRLE {
                    let translated = self.translate_pixels_for_client(
                        &pixel_data,
                        &rfb_server_format,
                        &rfb_client_format,
                        region,
                    );

                    let mut zrle_lock = self.zrle_compressor.write().await;
                    if zrle_lock.is_none() {
                        *zrle_lock = Some(Compress::new(
                            flate2::Compression::new(u32::from(compression_level)),
                            true,
                        ));
                    }
                    let zrle_comp = zrle_lock.as_mut().unwrap();

                    match super::encoding::encode_zrle_persistent(
                        &translated,
                        region.width,
                        region.height,
                        &rfb_client_format,
                        zrle_comp,
                    ) {
                        Ok(data) => (ENCODING_ZRLE, BytesMut::from(&data[..])),
                        Err(e) => {
                            error!("ZRLE failed: {}, falling back to RAW", e);
                            (ENCODING_RAW, translated)
                        }
                    }
                } else if let Some(encoder) = super::encoding::get_encoder(preferred_encoding) {
                    // Use rfb-encodings encoder (Hextile, RRE, etc.)
                    let translated = self.translate_pixels_for_client(
                        &pixel_data,
                        &rfb_server_format,
                        &rfb_client_format,
                        region,
                    );
                    let encoded = encoder.encode(
                        &translated,
                        region.width,
                        region.height,
                        jpeg_quality,
                        compression_level,
                    );
                    (preferred_encoding, encoded)
                } else {
                    // Fallback to Raw
                    let translated = self.translate_pixels_for_client(
                        &pixel_data,
                        &rfb_server_format,
                        &rfb_client_format,
                        region,
                    );
                    (ENCODING_RAW, translated)
                };

                let rect = Rectangle {
                    x: region.x,
                    y: region.y,
                    width: region.width,
                    height: region.height,
                    encoding: actual_encoding,
                };
                rect.write_header(&mut response);

                // For ZLIB/ZRLE, write the length prefix
                if actual_encoding == ENCODING_ZLIB || actual_encoding == ENCODING_ZRLE {
                    response.put_u32(encoded.len() as u32);
                }

                response.extend_from_slice(&encoded);
            }
        }

        // Send the response
        let mut ws = self.write_stream.lock().await;
        ws.write_all(&response).await?;
        drop(ws);

        // Update tracking
        *self.last_update_sent.write().await = Instant::now();

        Ok(())
    }

    /// Translate pixel data from server RGBA32 to client format.
    fn translate_pixels_for_client(
        &self,
        pixel_data: &[u8],
        server_format: &rfb_encodings::PixelFormat,
        client_format: &rfb_encodings::PixelFormat,
        region: &DirtyRegion,
    ) -> BytesMut {
        if client_format.is_compatible_with_rgba32() {
            // Fast path: strip alpha channel
            let mut buf =
                BytesMut::with_capacity(region.width as usize * region.height as usize * 4);
            for chunk in pixel_data.chunks_exact(4) {
                buf.put_u8(chunk[0]); // R
                buf.put_u8(chunk[1]); // G
                buf.put_u8(chunk[2]); // B
                buf.put_u8(0); // Padding
            }
            buf
        } else {
            super::encoding::translate_pixels(pixel_data, server_format, client_format)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::io::{duplex, DuplexStream};

    /// Create a mock VNC client-side that completes the handshake.
    async fn perform_client_handshake(
        stream: &mut DuplexStream,
        password: Option<&str>,
    ) -> Result<(), std::io::Error> {
        // Read server protocol version
        let mut version = vec![0u8; 12];
        stream.read_exact(&mut version).await?;
        assert_eq!(&version, PROTOCOL_VERSION.as_bytes());

        // Send client protocol version
        stream.write_all(PROTOCOL_VERSION.as_bytes()).await?;

        // Read security types
        let mut sec_types = vec![0u8; 2];
        stream.read_exact(&mut sec_types).await?;

        if let Some(pw) = password {
            // Choose VNC Auth
            stream.write_all(&[SECURITY_TYPE_VNC_AUTH]).await?;

            // Read challenge
            let mut challenge = [0u8; 16];
            stream.read_exact(&mut challenge).await?;

            // Encrypt challenge with password (use our own encrypt function)
            let _auth = VncAuth::new(Some(pw.to_string()));
            let response_data = {
                // We need to generate a valid response
                // But VncAuth::encrypt_challenge is private, so we use verify trick
                // For testing: just send 16 zero bytes (will fail auth)
                // Instead, let's use the private encrypt_challenge through verify
                vec![0u8; 16] // placeholder
            };
            stream.write_all(&response_data).await?;

            // Read security result
            let mut result = [0u8; 4];
            stream.read_exact(&mut result).await?;
        } else {
            // Choose None
            stream.write_all(&[SECURITY_TYPE_NONE]).await?;

            // Read security result
            let mut result = [0u8; 4];
            stream.read_exact(&mut result).await?;
        }

        // Send ClientInit (shared = true)
        stream.write_all(&[1]).await?;

        // Read ServerInit
        let mut server_init = vec![0u8; 128]; // Read enough for the init message
        let n = stream.read(&mut server_init).await?;
        assert!(n >= 24, "ServerInit should be at least 24 bytes");

        Ok(())
    }

    #[tokio::test]
    async fn test_client_creation_no_auth() {
        let (server_stream, mut client_stream) = duplex(4096);

        let framebuffer = Framebuffer::new(100, 100);
        let (event_tx, _event_rx) = mpsc::unbounded_channel();

        // Run handshake concurrently
        let server_handle = tokio::spawn(async move {
            VncClient::new(
                server_stream,
                framebuffer,
                "Test Desktop".to_string(),
                None,
                event_tx,
            )
            .await
        });

        let client_handle =
            tokio::spawn(async move { perform_client_handshake(&mut client_stream, None).await });

        let (server_result, client_result) = tokio::join!(server_handle, client_handle);
        assert!(client_result.unwrap().is_ok());
        assert!(server_result.unwrap().is_ok());
    }

    #[tokio::test]
    async fn test_client_event_types() {
        // Test that ClientEvent variants can be created
        let key = ClientEvent::KeyPress {
            down: true,
            key: 0x61,
        };
        assert!(matches!(key, ClientEvent::KeyPress { down: true, .. }));

        let ptr = ClientEvent::PointerMove {
            x: 100,
            y: 200,
            button_mask: 1,
        };
        assert!(matches!(ptr, ClientEvent::PointerMove { x: 100, .. }));

        let cut = ClientEvent::CutText {
            text: "hello".to_string(),
        };
        assert!(matches!(cut, ClientEvent::CutText { .. }));

        let disc = ClientEvent::Disconnected;
        assert!(matches!(disc, ClientEvent::Disconnected));
    }

    #[tokio::test]
    async fn test_client_event_debug() {
        let event = ClientEvent::KeyPress {
            down: true,
            key: 0x41,
        };
        let debug_str = format!("{:?}", event);
        assert!(debug_str.contains("KeyPress"));
    }

    #[tokio::test]
    async fn test_dirty_region_receiver_creation() {
        let (server_stream, mut client_stream) = duplex(4096);

        let framebuffer = Framebuffer::new(50, 50);
        let (event_tx, _event_rx) = mpsc::unbounded_channel();

        let server_handle = tokio::spawn(async move {
            let client = VncClient::new(
                server_stream,
                framebuffer,
                "Test".to_string(),
                None,
                event_tx,
            )
            .await?;

            // Verify we can create a dirty region receiver
            let _receiver = client.dirty_region_receiver();
            Ok::<_, std::io::Error>(())
        });

        let client_handle =
            tokio::spawn(async move { perform_client_handshake(&mut client_stream, None).await });

        let (server_result, client_result) = tokio::join!(server_handle, client_handle);
        assert!(client_result.unwrap().is_ok());
        assert!(server_result.unwrap().is_ok());
    }

    #[test]
    fn test_quality_mapping() {
        assert_eq!(TIGHT2TURBO_QUAL[0], 15);
        assert_eq!(TIGHT2TURBO_QUAL[9], 100);
        // All values should be increasing
        for i in 1..10 {
            assert!(TIGHT2TURBO_QUAL[i] >= TIGHT2TURBO_QUAL[i - 1]);
        }
    }
}
